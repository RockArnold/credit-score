"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These files will be auto-generated by genabi.mjs script
import { EncryptedCreditScoreAddresses } from "@/abi/EncryptedCreditScoreAddresses";
import { EncryptedCreditScoreABI } from "@/abi/EncryptedCreditScoreABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type CreditScoreInfoType = {
  abi: typeof EncryptedCreditScoreABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Get credit score contract info by chain ID
 * Returns ABI and contract address for the specified chain
 */
function getCreditScoreByChainId(
  chainId: number | undefined
): CreditScoreInfoType {
  if (!chainId) {
    return { abi: EncryptedCreditScoreABI.abi };
  }

  const entry =
    EncryptedCreditScoreAddresses[chainId.toString() as keyof typeof EncryptedCreditScoreAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: EncryptedCreditScoreABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: EncryptedCreditScoreABI.abi,
  };
}

export const useCreditScore = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [creditScoreHandle, setCreditScoreHandle] = useState<string | undefined>(undefined);
  const [qualificationHandle, setQualificationHandle] = useState<string | undefined>(undefined);
  const [clearCreditScore, setClearCreditScore] = useState<ClearValueType | undefined>(undefined);
  const [clearQualification, setClearQualification] = useState<ClearValueType | undefined>(undefined);
  const clearCreditScoreRef = useRef<ClearValueType>(undefined);
  const clearQualificationRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [hasData, setHasData] = useState<boolean>(false);

  const creditScoreRef = useRef<CreditScoreInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  const isDecrypted = creditScoreHandle && creditScoreHandle === clearCreditScore?.handle;

  const creditScore = useMemo(() => {
    const c = getCreditScoreByChainId(chainId);
    creditScoreRef.current = c;
    if (!c.address) {
      setMessage(`EncryptedCreditScore deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!creditScore) {
      return undefined;
    }
    return (Boolean(creditScore.address) && creditScore.address !== ethers.ZeroAddress);
  }, [creditScore]);

  const canGetCreditScore = useMemo(() => {
    return creditScore.address && ethersReadonlyProvider && !isRefreshing;
  }, [creditScore.address, ethersReadonlyProvider, isRefreshing]);

  const refreshCreditScore = useCallback(() => {
    console.log("[useCreditScore] call refreshCreditScore()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !creditScoreRef.current ||
      !creditScoreRef.current?.chainId ||
      !creditScoreRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setCreditScoreHandle(undefined);
      setQualificationHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = creditScoreRef.current.chainId;
    const thisContractAddress = creditScoreRef.current.address;
    const userAddress = ethersSigner?.address;

    if (!userAddress) {
      setMessage("No signer address available");
      isRefreshingRef.current = false;
      setIsRefreshing(false);
      return;
    }

    const thisContract = new ethers.Contract(
      thisContractAddress,
      creditScoreRef.current.abi,
      ethersReadonlyProvider
    );

    Promise.all([
      thisContract.hasCreditData(userAddress),
      thisContract.getCreditScore(userAddress).catch(() => ethers.ZeroHash),
      thisContract.getQualificationStatus(userAddress).catch(() => ethers.ZeroHash),
    ])
      .then(([hasDataResult, creditScoreValue, qualificationValue]) => {
        console.log("[useCreditScore] hasCreditData=" + hasDataResult);
        console.log("[useCreditScore] getCreditScore()=" + creditScoreValue);
        console.log("[useCreditScore] getQualificationStatus()=" + qualificationValue);
        
        if (
          sameChain.current(thisChainId) &&
          thisContractAddress === creditScoreRef.current?.address
        ) {
          setHasData(hasDataResult);
          setCreditScoreHandle(creditScoreValue);
          setQualificationHandle(qualificationValue);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("EncryptedCreditScore.getCreditScore() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  useEffect(() => {
    refreshCreditScore();
  }, [refreshCreditScore]);

  const canDecrypt = useMemo(() => {
    return (
      creditScore.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      creditScoreHandle &&
      creditScoreHandle !== ethers.ZeroHash &&
      creditScoreHandle !== clearCreditScore?.handle
    );
  }, [
    creditScore.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    creditScoreHandle,
    clearCreditScore,
  ]);

  const decryptCreditScore = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!creditScore.address || !instance || !ethersSigner) {
      return;
    }

    if (creditScoreHandle === clearCreditScoreRef.current?.handle) {
      return;
    }

    if (!creditScoreHandle || creditScoreHandle === ethers.ZeroHash) {
      setClearCreditScore(undefined);
      clearCreditScoreRef.current = undefined;
      return;
    }

    const thisChainId = chainId;
    const thisContractAddress = creditScore.address;
    const thisCreditScoreHandle = creditScoreHandle;
    const thisQualificationHandle = qualificationHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypt");

    const run = async () => {
      const isStale = () =>
        thisContractAddress !== creditScoreRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [creditScore.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        const handles = [
          { handle: thisCreditScoreHandle, contractAddress: thisContractAddress },
        ];
        if (thisQualificationHandle && thisQualificationHandle !== ethers.ZeroHash) {
          handles.push({ handle: thisQualificationHandle, contractAddress: thisContractAddress });
        }

        const res = await instance.userDecrypt(
          handles,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        const creditScoreHandleKey = thisCreditScoreHandle as `0x${string}`;
        setClearCreditScore({ handle: thisCreditScoreHandle, clear: res[creditScoreHandleKey] });
        clearCreditScoreRef.current = {
          handle: thisCreditScoreHandle,
          clear: res[creditScoreHandleKey],
        };

        if (thisQualificationHandle) {
          const qualificationHandleKey = thisQualificationHandle as `0x${string}`;
          if (res[qualificationHandleKey] !== undefined) {
            setClearQualification({ handle: thisQualificationHandle, clear: res[qualificationHandleKey] });
            clearQualificationRef.current = {
              handle: thisQualificationHandle,
              clear: res[qualificationHandleKey],
            };
          }
        }

        setMessage(
          "Credit score clear value is " + clearCreditScoreRef.current.clear
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    creditScore.address,
    instance,
    creditScoreHandle,
    qualificationHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const canSubmit = useMemo(() => {
    return (
      creditScore.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [creditScore.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const submitCreditData = useCallback(
    (income: number, debtRatio: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!creditScore.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = creditScore.address;
      const thisEthersSigner = ethersSigner;
      const thisContract = new ethers.Contract(
        thisContractAddress,
        creditScore.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Start encrypting credit data...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisContractAddress !== creditScoreRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          input.add32(income);
          input.add32(debtRatio);
          // padding third encrypted input to match contract signature
          input.add32(0);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore submit");
            return;
          }

          setMessage("Call submitCreditData...");

          const tx: ethers.TransactionResponse =
            await thisContract.submitCreditData(
              enc.handles[0],
              enc.inputProof,
              enc.handles[1],
              enc.inputProof,
              enc.handles[2],
              enc.inputProof
            );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Submit completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore submit");
            return;
          }

          refreshCreditScore();
        } catch (e) {
          setMessage(`Submit Failed! ${e}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      creditScore.address,
      creditScore.abi,
      instance,
      chainId,
      refreshCreditScore,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: creditScore.address,
    canDecrypt,
    canGetCreditScore,
    canSubmit,
    submitCreditData,
    decryptCreditScore,
    refreshCreditScore,
    isDecrypted,
    message,
    creditScore: clearCreditScore?.clear,
    qualification: clearQualification?.clear,
    creditScoreHandle,
    qualificationHandle,
    isDecrypting,
    isRefreshing,
    isSubmitting,
    isDeployed,
    hasData,
  };
};

